/*
 * NobotPlayer.ts
 * author: evan kirkiles
 * created on Sat Jun 25 2022
 * 2022 the nobot space,
 */
import _ from "lodash";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import * as Utils from "../core/FunctionLibrary";
import { KeyBinding } from "../core/KeyBinding";
import { EntityType } from "../enums/EntityType";
import { INobotAI } from "../interfaces/INobotAI";
import { INobotState } from "../interfaces/INobotState";
import { IWorldEntity } from "../interfaces/IWorldEntity";
import { World } from "../world/World";
import { Idle, NobotState, Walk } from "./states/_stateLibrary";

/**
 * The NobotPlayer class is the controller interface for the Nobot, which is
 * loaded into the scene based on the user's own Nobot model. It takes in
 * information about the Nobot mesh and creates a corresponding collider that
 * is scaled based on the Nobot's own proportions.
 */
export class Nobot extends THREE.Object3D implements IWorldEntity {
  // worldentity + updatable properties
  public updateOrder: number = 1;
  public entityType: EntityType = EntityType.Nobot;

  /* -------------------------------- GEOMETRY -------------------------------- */

  // model / geometry
  public height: number = 0;
  public tiltContainer: THREE.Group;
  public modelContainer: THREE.Group;
  public materials: THREE.Material[] = [];
  public mixer: THREE.AnimationMixer;
  public animations!: THREE.AnimationClip[];
  public currAnim?: THREE.AnimationClip;

  /* -------------------------------- MOVEMENT -------------------------------- */

  // movement state
  public moveSpeed: number = 2;
  public angularVelocity: number = 0;
  public acceleration: THREE.Vector3 = new THREE.Vector3();
  public velocity: THREE.Vector3 = new THREE.Vector3();
  public velocityTarget: THREE.Vector3 = new THREE.Vector3();
  // rotation:
  public orientation: THREE.Vector3 = new THREE.Vector3(0, 0, 1);
  public orientationTarget: THREE.Vector3 = new THREE.Vector3(0, 0, 1);
  public viewVector: THREE.Vector3;
  // arcade velocity refers to top-down local XZ rotation
  public arcadeVelocityInfluence: THREE.Vector3 = new THREE.Vector3();
  public arcadeVelocityIsAdditive: boolean = false;

  /* ------------------------------- INTERACTION ------------------------------ */

  // world references
  public world?: World;

  // current state
  public nobotState!: INobotState;
  public behavior?: INobotAI;

  // action map
  public actions: { [key: string]: KeyBinding };

  /* -------------------------------------------------------------------------- */
  /*                               INITIALIZATION                               */
  /* -------------------------------------------------------------------------- */

  /**
   * Construct the Nobot Player from the GLTF model downloaded from the server.
   * @param gltf The custom nobot GLTF generated by the blender pipeline
   */
  constructor(gltf: GLTF) {
    super();

    /* ------------------------------- GEOMETRIES ------------------------------- */

    // initialize mesh + animation data
    this.readNobotData(gltf);
    this.readNobotAnimations(gltf);

    // the visuals group is centered for easy nobot tilting
    this.tiltContainer = new THREE.Group();
    this.add(this.tiltContainer);

    // model container is used to reliably ground the character, as animation
    // can alter the position of the model itself
    this.modelContainer = new THREE.Group();
    this.modelContainer.position.y = -0.57;
    this.tiltContainer.add(this.modelContainer);
    this.modelContainer.add(gltf.scene);

    // set up animation mixer
    this.mixer = new THREE.AnimationMixer(gltf.scene);

    // set up view vector
    this.viewVector = new THREE.Vector3();

    /* ------------------------------- INTERACTION ------------------------------ */

    // map actions to keys
    this.actions = {
      up: new KeyBinding("KeyW"),
      down: new KeyBinding("KeyS"),
      left: new KeyBinding("KeyA"),
      right: new KeyBinding("KeyD"),
      run: new KeyBinding("ShiftLeft"),
      jump: new KeyBinding("Space"),
      use: new KeyBinding("KeyE"),
      primary: new KeyBinding("Mouse0"),
      secondary: new KeyBinding("Mouse1"),
    };

    // begin with the idle state
    this.setState(new Idle(this));
  }

  /* -------------------------------------------------------------------------- */
  /*                                  STATEFULS                                 */
  /* -------------------------------------------------------------------------- */

  /**
   * Updates the influence of arcade controls on the nobot
   */
  public setArcadeVelocityInfluence(
    x: number,
    y: number = x,
    z: number = x
  ): void {
    this.arcadeVelocityInfluence.set(x, y, z);
  }

  /**
   * Updates the target arcade velocity
   */
  public setArcadeVelocityTarget(
    z: number,
    x: number = 0,
    y: number = 0
  ): void {
    this.velocityTarget.x = x;
    this.velocityTarget.y = y;
    this.velocityTarget.z = z;
  }

  /**
   * Sets the direction in which the nobot is looking at
   */
  public setViewVector(vector: THREE.Vector3): void {
    this.viewVector.copy(vector).normalize();
  }

  /**
   * Sets the orientation of the Nobot, usually for beginning an interaction
   * @param vector The look vector
   * @param instantly Whether or not to change orientation instantly
   */
  public setOrientation(
    vector: THREE.Vector3,
    instantly: boolean = false
  ): void {
    const lookVector = new THREE.Vector3().copy(vector).setY(0).normalize();
    this.orientationTarget.copy(lookVector);
    if (instantly) {
      this.orientation.copy(lookVector);
    }
  }

  /**
   * Sets the position immediately of the nobot
   */
  public setPosition(x: number, y: number, z: number): void {
    this.position.set(x, y, z);
  }

  /**
   * Sets the state of the Nobot.
   * @param state
   */
  public setState(state: INobotState): void {
    this.nobotState = state;
    // this.nobotState.onInputChange();
  }

  /**
   * Sets the state of the nobot in a serialized manner (for tree-shaking the
   * state dict).
   * @param state
   */
  public setStateSerialized(state: NobotState): void {
    switch (state) {
      case NobotState.WALK:
        this.setState(new Walk(this));
        break;
      case NobotState.IDLE:
        this.setState(new Idle(this));
        break;
    }
  }

  /**
   * Begins an animation, returning how long it will take.
   * @param animName The name of the animation in the Nobot GLTF
   * @param fadeIn How long to take in fading in the animation
   */
  public setAnimation(animName: string, fadeIn: number): number {
    if (!this.mixer) return 0;
    const clip = THREE.AnimationClip.findByName(this.animations, animName);
    const action = this.mixer.clipAction(clip);
    if (action === null) {
      console.error(`Animation ${animName} not found!`);
      return 0;
    }
    this.mixer.stopAllAction();
    if (this.currAnim) {
      const currAction = this.mixer.clipAction(this.currAnim);
      currAction.loop = THREE.LoopPingPong;
      currAction.timeScale = -1;
      currAction.play();
      currAction.crossFadeTo(action, fadeIn, false);
      action.timeScale = 1;
      action.loop = THREE.LoopRepeat;
    } else {
      action.fadeIn(fadeIn);
    }
    action.play();
    this.currAnim = clip;
    return action.getClip().duration;
  }

  /* -------------------------------------------------------------------------- */
  /*                                WORLD ENTITY                                */
  /* -------------------------------------------------------------------------- */

  /**
   * Add the nobot into the world at a spawn position.
   * @param world The target world instance
   */
  public addToWorld(world: World): void {
    // check to make sure the nobot is not already in the world
    if (_.includes(world.nobots, this)) {
      console.warn("Could not add NOBOT to world it already exists in!");
      // if not, then add the nobot to the world
    } else {
      this.world = world;
      world.nobots.push(this);
      world.graphicsWorld.add(this);
    }
  }

  /**
   * Remove the nobot from the world
   * @param world The target world instance
   */
  public removeFromWorld(world: World): void {
    // check to make sure the nobot is still in the world
    if (!_.includes(world.nobots, this)) {
      console.warn("Could not remove NOBOT from a world it is not in!");
      // if so, then remove the nobot from the world
    } else {
      this.world = undefined;

      // remove from nobots, world, body
      _.pull(world.nobots, this);
      world.graphicsWorld.remove(this);
    }
  }

  /* -------------------------------------------------------------------------- */
  /*                                 UPDATE LOOP                                */
  /* -------------------------------------------------------------------------- */

  /**
   * Perform a single step on the nobot character
   * @param timestep
   * @param unscaledTimeStep
   */
  public update(timestep: number): void {
    // update current external states
    this.behavior?.update(timestep);
    this.nobotState?.update(timestep);

    // update animations
    if (this.mixer) this.mixer.update(timestep);

    // update the global transsform of the object
    this.updateMatrixWorld();
  }

  /* -------------------------------------------------------------------------- */
  /*                               INITIALIZATION                               */
  /* -------------------------------------------------------------------------- */

  /**
   * Reads in Nobot mesh data from the GLTF
   * @param gltf The server-generated GLTF nobot model
   */
  public readNobotData(gltf: GLTF): void {
    gltf.scene.traverse((child) => {
      child.userData.ignoredByCamera = true;
      if (child instanceof THREE.Mesh && child.isMesh) {
        Utils.setUpMeshProperties(child);
        if (child.material) {
          this.materials.push(child.material);
        }
      }
    });
  }

  /**
   * Reads in Nobot animations from the GLTF
   * @param gltf The server-generated GLTF nobot model
   */
  public readNobotAnimations(gltf: GLTF): void {
    this.animations = gltf.animations;
  }

  /* -------------------------------------------------------------------------- */
  /*                                  HANDLERS                                  */
  /* -------------------------------------------------------------------------- */

  /**
   * Triggers an action from an input event.
   * @param actionName The name of the action in the keyBinding
   * @param value An on/off toggle for the action
   */
  public triggerAction(actionName: string, value: boolean): void {
    // Get action and set its parameters
    const action = this.actions[actionName];
    if (action.isPressed !== value) {
      action.isPressed = value;
      // reset the 'just' attributes
      action.justPressed = false;
      action.justReleased = false;
      // set the 'just' attributes
      if (value) action.justPressed = true;
      else action.justReleased = true;
      // tell player to handle states according to input
      this.nobotState.onInputChange();
      // reset the 'just' attributes
      action.justPressed = false;
      action.justReleased = false;
    }
  }

  /* -------------------------------------------------------------------------- */
  /*                                   CAMERA                                   */
  /* -------------------------------------------------------------------------- */

  /**
   * The direction of local movement of the character
   * @returns
   */
  public getLocalMovementDirection(): THREE.Vector3 {
    const positiveX = this.actions.right.isPressed ? -1 : 0;
    const negativeX = this.actions.left.isPressed ? 1 : 0;
    const positiveZ = this.actions.up.isPressed ? 1 : 0;
    const negativeZ = this.actions.down.isPressed ? -1 : 0;
    return new THREE.Vector3(
      positiveX + negativeX,
      0,
      positiveZ + negativeZ
    ).normalize();
  }

  /**
   * Get orientation movement vector relative to the camera
   */
  public getCameraRelativeMovementVector(): THREE.Vector3 {
    const localDirection = this.getLocalMovementDirection();
    const flatViewVector = new THREE.Vector3(
      this.viewVector.x,
      0,
      this.viewVector.z
    ).normalize();
    return Utils.applyVectorMatrixXZ(flatViewVector, localDirection);
  }

  /**
   * Get orientation movement vector relative to the camera
   */
  public setCameraRelativeOrientationTarget(): void {
    const moveVector = this.getCameraRelativeMovementVector();
    if (moveVector.x === 0 && moveVector.y === 0 && moveVector.z === 0) {
      this.setOrientation(this.orientation);
    } else {
      this.setOrientation(moveVector);
    }
  }

  /**
   * Rotates the model to be in line with the orientation
   */
  public rotateModel(): void {
    this.lookAt(
      this.position.x + this.orientation.x,
      this.position.y + this.orientation.y,
      this.position.z + this.orientation.z
    );
    this.tiltContainer.rotation.z =
      -this.angularVelocity * 1.2 * this.velocity.length();
    this.tiltContainer.position.setY(
      Math.cos(Math.abs(this.angularVelocity * 2.3 * this.velocity.length())) /
        2 -
        0.5
    );
  }
}
